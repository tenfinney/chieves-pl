{"version":3,"file":"owners.ab05f8ae.js","sources":["../../../../node_modules/graphql/jsutils/isObjectLike.mjs","../../../../node_modules/graphql/jsutils/invariant.mjs","../../../../node_modules/graphql/language/location.mjs","../../../../node_modules/graphql/language/printLocation.mjs","../../../../node_modules/graphql/error/GraphQLError.mjs","../../../../node_modules/graphql/error/syntaxError.mjs","../../../../node_modules/graphql/language/directiveLocation.mjs","../../../../node_modules/graphql/language/tokenKind.mjs","../../../../node_modules/graphql/language/lexer.mjs","../../../../node_modules/graphql/language/parser.mjs","../../../../node_modules/graphql-tag/lib/index.js","../../../../node_modules/@apollo/client/react/hooks/useApolloClient.js","../../../../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js","../../../../node_modules/@apollo/client/react/parser/index.js","../../../../node_modules/@apollo/client/react/hooks/useQuery.js","../../../../node_modules/@apollo/client/react/hooks/useLazyQuery.js","../../src/pages/owners.tsx"],"sourcesContent":["/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, {\n    source,\n    positions: [position],\n  });\n}\n","/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation;\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n\nexport { DirectiveLocation };\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind;\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n\nexport { TokenKind };\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport { useContext } from 'react';\nimport { getApolloContext } from \"../context/index.js\";\nexport function useApolloClient(override) {\n    var context = useContext(getApolloContext());\n    var client = override || context.client;\n    __DEV__ ? invariant(!!client, 'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n        'instance in via options.') : invariant(!!client, 29);\n    return client;\n}\n//# sourceMappingURL=useApolloClient.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from 'react';\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false;\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey];\nexport var useSyncExternalStore = realHook || (function (subscribe, getSnapshot, getServerSnapshot) {\n    var value = getSnapshot();\n    if (__DEV__ &&\n        !didWarnUncachedGetSnapshot &&\n        value !== getSnapshot()) {\n        didWarnUncachedGetSnapshot = true;\n        __DEV__ && invariant.error('The result of getSnapshot should be cached to avoid an infinite loop');\n    }\n    var _a = React.useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _a[0].inst, forceUpdate = _a[1];\n    if (canUseLayoutEffect) {\n        React.useLayoutEffect(function () {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        }, [subscribe, value, getSnapshot]);\n    }\n    else {\n        Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n    }\n    React.useEffect(function () {\n        if (checkIfSnapshotChanged(inst)) {\n            forceUpdate({ inst: inst });\n        }\n        return subscribe(function handleStoreChange() {\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        });\n    }, [subscribe]);\n    return value;\n});\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nexport var DocumentType;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\nvar cache = new Map();\nexport function operationName(type) {\n    var name;\n    switch (type) {\n        case DocumentType.Query:\n            name = 'Query';\n            break;\n        case DocumentType.Mutation:\n            name = 'Mutation';\n            break;\n        case DocumentType.Subscription:\n            name = 'Subscription';\n            break;\n    }\n    return name;\n}\nexport function parser(document) {\n    var cached = cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n    __DEV__ ? invariant(!!document && !!document.kind, \"Argument of \".concat(document, \" passed to parser was not a valid GraphQL \") +\n        \"DocumentNode. You may need to use 'graphql-tag' or another method \" +\n        \"to convert your operation into a document\") : invariant(!!document && !!document.kind, 30);\n    var fragments = [];\n    var queries = [];\n    var mutations = [];\n    var subscriptions = [];\n    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {\n        var x = _a[_i];\n        if (x.kind === 'FragmentDefinition') {\n            fragments.push(x);\n            continue;\n        }\n        if (x.kind === 'OperationDefinition') {\n            switch (x.operation) {\n                case 'query':\n                    queries.push(x);\n                    break;\n                case 'mutation':\n                    mutations.push(x);\n                    break;\n                case 'subscription':\n                    subscriptions.push(x);\n                    break;\n            }\n        }\n    }\n    __DEV__ ? invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), \"Passing only a fragment to 'graphql' is not yet supported. \" +\n        \"You must include a query, subscription or mutation as well\") : invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), 31);\n    __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" +\n        \"\".concat(document, \" had \").concat(queries.length, \" queries, \").concat(subscriptions.length, \" \") +\n        \"subscriptions and \".concat(mutations.length, \" mutations. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 32);\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = DocumentType.Subscription;\n    var definitions = queries.length\n        ? queries\n        : mutations.length\n            ? mutations\n            : subscriptions;\n    __DEV__ ? invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \".concat(document, \" had \") +\n        \"\".concat(definitions.length, \" definitions. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(definitions.length === 1, 33);\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === 'Name') {\n        name = definition.name.value;\n    }\n    else {\n        name = 'data';\n    }\n    var payload = { name: name, type: type, variables: variables };\n    cache.set(document, payload);\n    return payload;\n}\nexport function verifyDocumentType(document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    __DEV__ ? invariant(operation.type === type, \"Running a \".concat(requiredOperationName, \" requires a graphql \") +\n        \"\".concat(requiredOperationName, \", but a \").concat(usedOperationName, \" was used instead.\")) : invariant(operation.type === type, 34);\n}\n//# sourceMappingURL=index.js.map","import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useCallback, useContext, useMemo, useRef, useState, } from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus, } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n    var stateRef = useRef();\n    if (!stateRef.current ||\n        client !== stateRef.current.client ||\n        query !== stateRef.current.query) {\n        stateRef.current = new InternalState(client, query, stateRef.current);\n    }\n    var state = stateRef.current;\n    var _a = useState(0), _tick = _a[0], setTick = _a[1];\n    state.forceUpdate = function () {\n        setTick(function (tick) { return tick + 1; });\n    };\n    return state;\n}\nvar InternalState = (function () {\n    function InternalState(client, query, previous) {\n        this.client = client;\n        this.query = query;\n        this.asyncResolveFns = new Set();\n        this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();\n        this.ssrDisabledResult = maybeDeepFreeze({\n            loading: true,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.loading,\n        });\n        this.skipStandbyResult = maybeDeepFreeze({\n            loading: false,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.ready,\n        });\n        this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n        verifyDocumentType(query, DocumentType.Query);\n        var previousResult = previous && previous.result;\n        var previousData = previousResult && previousResult.data;\n        if (previousData) {\n            this.previousData = previousData;\n        }\n    }\n    InternalState.prototype.forceUpdate = function () {\n        __DEV__ && invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n    };\n    InternalState.prototype.asyncUpdate = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this.asyncResolveFns.add(resolve);\n            _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);\n            _this.forceUpdate();\n        });\n    };\n    InternalState.prototype.useQuery = function (options) {\n        var _this = this;\n        this.renderPromises = useContext(getApolloContext()).renderPromises;\n        this.useOptions(options);\n        var obsQuery = this.useObservableQuery();\n        var result = useSyncExternalStore(useCallback(function () {\n            if (_this.renderPromises) {\n                return function () { };\n            }\n            var onNext = function () {\n                var previousResult = _this.result;\n                var result = obsQuery.getCurrentResult();\n                if (previousResult &&\n                    previousResult.loading === result.loading &&\n                    previousResult.networkStatus === result.networkStatus &&\n                    equal(previousResult.data, result.data)) {\n                    return;\n                }\n                _this.setResult(result);\n            };\n            var onError = function (error) {\n                var last = obsQuery[\"last\"];\n                subscription.unsubscribe();\n                try {\n                    obsQuery.resetLastResults();\n                    subscription = obsQuery.subscribe(onNext, onError);\n                }\n                finally {\n                    obsQuery[\"last\"] = last;\n                }\n                if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n                    throw error;\n                }\n                var previousResult = _this.result;\n                if (!previousResult ||\n                    (previousResult && previousResult.loading) ||\n                    !equal(error, previousResult.error)) {\n                    _this.setResult({\n                        data: (previousResult && previousResult.data),\n                        error: error,\n                        loading: false,\n                        networkStatus: NetworkStatus.error,\n                    });\n                }\n            };\n            var subscription = obsQuery.subscribe(onNext, onError);\n            return function () { return subscription.unsubscribe(); };\n        }, [\n            obsQuery,\n            this.renderPromises,\n            this.client.disableNetworkFetches,\n        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });\n        this.unsafeHandlePartialRefetch(result);\n        var queryResult = this.toQueryResult(result);\n        if (!queryResult.loading && this.asyncResolveFns.size) {\n            this.asyncResolveFns.forEach(function (resolve) { return resolve(queryResult); });\n            this.asyncResolveFns.clear();\n        }\n        return queryResult;\n    };\n    InternalState.prototype.useOptions = function (options) {\n        var _a;\n        var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n        var currentWatchQueryOptions = this.watchQueryOptions;\n        if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n            !equal(watchQueryOptions, currentWatchQueryOptions)) {\n            this.watchQueryOptions = watchQueryOptions;\n            if (currentWatchQueryOptions && this.observable) {\n                this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n                this.observable.reobserve(this.getObsQueryOptions());\n                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n                this.result = void 0;\n            }\n        }\n        this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n        this.onError = options.onError || InternalState.prototype.onError;\n        if ((this.renderPromises || this.client.disableNetworkFetches) &&\n            this.queryHookOptions.ssr === false &&\n            !this.queryHookOptions.skip) {\n            this.result = this.ssrDisabledResult;\n        }\n        else if (this.queryHookOptions.skip ||\n            this.watchQueryOptions.fetchPolicy === 'standby') {\n            this.result = this.skipStandbyResult;\n        }\n        else if (this.result === this.ssrDisabledResult ||\n            this.result === this.skipStandbyResult) {\n            this.result = void 0;\n        }\n    };\n    InternalState.prototype.getObsQueryOptions = function () {\n        var toMerge = [];\n        var globalDefaults = this.client.defaultOptions.watchQuery;\n        if (globalDefaults)\n            toMerge.push(globalDefaults);\n        if (this.queryHookOptions.defaultOptions) {\n            toMerge.push(this.queryHookOptions.defaultOptions);\n        }\n        toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n        return toMerge.reduce(mergeOptions);\n    };\n    InternalState.prototype.createWatchQueryOptions = function (_a) {\n        var _b;\n        if (_a === void 0) { _a = {}; }\n        var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, displayName = _a.displayName, defaultOptions = _a.defaultOptions, otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\", \"defaultOptions\"]);\n        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\n        if (this.renderPromises &&\n            (watchQueryOptions.fetchPolicy === 'network-only' ||\n                watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n            watchQueryOptions.fetchPolicy = 'cache-first';\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n            Object.assign(watchQueryOptions, {\n                initialFetchPolicy: initialFetchPolicy,\n                fetchPolicy: 'standby',\n            });\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||\n                    this.getDefaultFetchPolicy();\n        }\n        return watchQueryOptions;\n    };\n    InternalState.prototype.getDefaultFetchPolicy = function () {\n        var _a, _b;\n        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\n            \"cache-first\");\n    };\n    InternalState.prototype.onCompleted = function (data) { };\n    InternalState.prototype.onError = function (error) { };\n    InternalState.prototype.useObservableQuery = function () {\n        var obsQuery = this.observable =\n            this.renderPromises\n                && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n                || this.observable\n                || this.client.watchQuery(this.getObsQueryOptions());\n        this.obsQueryFields = useMemo(function () { return ({\n            refetch: obsQuery.refetch.bind(obsQuery),\n            reobserve: obsQuery.reobserve.bind(obsQuery),\n            fetchMore: obsQuery.fetchMore.bind(obsQuery),\n            updateQuery: obsQuery.updateQuery.bind(obsQuery),\n            startPolling: obsQuery.startPolling.bind(obsQuery),\n            stopPolling: obsQuery.stopPolling.bind(obsQuery),\n            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n        }); }, [obsQuery]);\n        var ssrAllowed = !(this.queryHookOptions.ssr === false ||\n            this.queryHookOptions.skip);\n        if (this.renderPromises && ssrAllowed) {\n            this.renderPromises.registerSSRObservable(obsQuery);\n            if (obsQuery.getCurrentResult().loading) {\n                this.renderPromises.addObservableQueryPromise(obsQuery);\n            }\n        }\n        return obsQuery;\n    };\n    InternalState.prototype.setResult = function (nextResult) {\n        var previousResult = this.result;\n        if (previousResult && previousResult.data) {\n            this.previousData = previousResult.data;\n        }\n        this.result = nextResult;\n        this.forceUpdate();\n        this.handleErrorOrCompleted(nextResult);\n    };\n    InternalState.prototype.handleErrorOrCompleted = function (result) {\n        if (!result.loading) {\n            if (result.error) {\n                this.onError(result.error);\n            }\n            else if (result.data) {\n                this.onCompleted(result.data);\n            }\n        }\n    };\n    InternalState.prototype.getCurrentResult = function () {\n        if (!this.result) {\n            this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n        }\n        return this.result;\n    };\n    InternalState.prototype.toQueryResult = function (result) {\n        var queryResult = this.toQueryResultCache.get(result);\n        if (queryResult)\n            return queryResult;\n        var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n        this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));\n        if (!queryResult.error && isNonEmptyArray(result.errors)) {\n            queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n        }\n        return queryResult;\n    };\n    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n        if (result.partial &&\n            this.queryHookOptions.partialRefetch &&\n            !result.loading &&\n            (!result.data || Object.keys(result.data).length === 0) &&\n            this.observable.options.fetchPolicy !== 'cache-only') {\n            Object.assign(result, {\n                loading: true,\n                networkStatus: NetworkStatus.refetch,\n            });\n            this.observable.refetch();\n        }\n    };\n    return InternalState;\n}());\n//# sourceMappingURL=useQuery.js.map","import { __assign } from \"tslib\";\nimport { useCallback, useMemo, useRef } from 'react';\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nvar EAGER_METHODS = [\n    'refetch',\n    'reobserve',\n    'fetchMore',\n    'updateQuery',\n    'startPolling',\n    'subscribeToMore',\n];\nexport function useLazyQuery(query, options) {\n    var internalState = useInternalState(useApolloClient(options && options.client), query);\n    var execOptionsRef = useRef();\n    var merged = execOptionsRef.current\n        ? mergeOptions(options, execOptionsRef.current)\n        : options;\n    var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), { skip: !execOptionsRef.current }));\n    var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy ||\n        internalState.getDefaultFetchPolicy();\n    var result = Object.assign(useQueryResult, {\n        called: !!execOptionsRef.current,\n    });\n    var eagerMethods = useMemo(function () {\n        var eagerMethods = {};\n        var _loop_1 = function (key) {\n            var method = result[key];\n            eagerMethods[key] = function () {\n                if (!execOptionsRef.current) {\n                    execOptionsRef.current = Object.create(null);\n                    internalState.forceUpdate();\n                }\n                return method.apply(this, arguments);\n            };\n        };\n        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n            var key = EAGER_METHODS_1[_i];\n            _loop_1(key);\n        }\n        return eagerMethods;\n    }, []);\n    Object.assign(result, eagerMethods);\n    var execute = useCallback(function (executeOptions) {\n        execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {\n            fetchPolicy: initialFetchPolicy,\n        };\n        var promise = internalState\n            .asyncUpdate()\n            .then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });\n        promise.catch(function () { });\n        return promise;\n    }, []);\n    return [execute, result];\n}\n//# sourceMappingURL=useLazyQuery.js.map","import { gql, useLazyQuery } from '@apollo/client'\nimport {\n  chakra, Box, Heading, ListItem, OrderedList, Text,\n  Alert, AlertIcon, AlertTitle, AlertDescription,\n} from '@chakra-ui/react'\nimport React, { useEffect, useMemo, useState } from 'react'\nimport contractAddress from '../contracts/polygon/BulkDisbursableNFTs.address'\nimport {\n  useParams, useSearchParams, Link as ReactRouterLink,\n} from 'react-router-dom'\nimport { httpURL, deregexify, capitalize } from '@/lib/helpers'\nimport { HomeLink } from '@/components'\nimport { useWeb3 } from '@/lib/hooks'\nimport { contractNetwork } from '@/config'\nimport { Helmet } from 'react-helmet'\n\nconst RouterLink = chakra(ReactRouterLink)\n\nconst LIMIT = 100 // The Graph's return limit\n\nconst ownersQuery = {\n  polygon: gql`\n    query NFTOwners(\n      $tokenId: String\n      $contractAddress: String\n      $startAfter: String\n    ) {\n      nfts(where:{ \n        contract: $contractAddress,\n        tokenID: $tokenId\n      }) {\n        ownership(where: {\n          id_gt: $startAfter\n        }) {\n          id\n          owner\n          quantity\n        }\n      }\n    }\n  `,\n}\n\nexport type Ownership = {\n  id: string\n  owner: string\n  quantity: number\n}\n\nexport const Owners = () => {\n  const { nftId } = useParams() \n  const tokenId = useMemo(() => (\n    deregexify(Array.isArray(nftId) ? nftId[0] : nftId)\n  ), [nftId])\n  const [params] = useSearchParams()\n  const startAfter = params.get('start_after') ?? ''\n  const offset = params.get('offset') ?? 0\n  const [ownerships, setOwnerships] = (\n    useState<Array<Ownership>>([])\n  )\n\n  const decId = tokenId ? BigInt(tokenId).toString(10) : null\n  const query = useMemo(() => (\n    ownersQuery[contractNetwork as keyof typeof ownersQuery]\n  ), [])\n\n  const [\n    search,\n    {\n      loading,\n      error: { message: queryError } = { message: null },\n      data\n    }\n  ] = (\n    useLazyQuery(query ?? gql`query Empty { id }`)\n  )\n  useEffect(() => {\n    if(query) {\n      search({ variables: {\n        tokenId: decId,\n        contractAddress: contractAddress.toLowerCase(),\n        startAfter,\n      } })\n    }\n  }, [decId, startAfter, query, search])\n\n  const [title, setTitle] = useState('Unknown')\n  const { ensProvider, roContract } = useWeb3()\n  const [error, setError] = useState(\n    (query == null ? (\n      'Retrieving owners requires access to a subgraph'\n      + ' & one hasn’t been configured for the '\n      + ` ${capitalize(contractNetwork)} network.`\n     ) : ( queryError ))\n  )\n\n  useEffect(\n    () => query && setError(queryError),\n    [query, queryError],\n  )\n\n  useEffect(() => {\n    const lookup = async () => {\n      if(tokenId) {\n        const uri = await roContract?.uri(tokenId)\n        if(!uri) return\n        const response = await fetch(httpURL(uri)!)\n        const data = await response.json()\n        setTitle(data.name)\n      }\n    }\n    lookup()\n  }, [tokenId, roContract])\n\n  useEffect(() => {\n    const process = async () => {\n      if(data) {\n        if(data.nfts.length > 1 ) {\n          throw new Error(`Retrieved ${data.nfts.length} Tokens`)\n        }\n        if (data.nfts.length === 1) {\n          setOwnerships(\n            await Promise.all(\n              data.nfts[0].ownership.map(\n                async (oship: Ownership) => {\n                  let { owner } = oship\n                  const ens = (\n                    await ensProvider?.lookupAddress(owner)\n                  )\n                  if(ens) {\n                    owner = ens \n                  }\n                  const { quantity, id } = oship\n                  return { owner, quantity, id }\n                }  \n              )\n            )\n          )\n        }\n      }\n    }\n    process()\n  }, [data, ensProvider])\n\n  if(loading) return <>Loading…</>\n\n  return (\n    <Box ml={8}>\n      <Helmet>\n        <title>Owners</title>\n      </Helmet>\n\n      <HomeLink/>\n      <Heading mt={10} fontSize={20}>\n        {title}\n      </Heading>\n      {error && (\n        <Alert status=\"error\">\n          <AlertIcon/>\n          <AlertTitle>¡Error!</AlertTitle>\n          <AlertDescription>{error}</AlertDescription>\n        </Alert>\n      )}\n      {ownerships.length === 0 ? (\n        <Alert status=\"warning\">\n          <AlertIcon/>\n          <AlertTitle>Empty!</AlertTitle>\n          <AlertDescription>\n            No owners found for token #{nftId}.\n          </AlertDescription>\n        </Alert>\n      ) : (\n        <OrderedList start={Number(offset) + 1}>\n          {ownerships.map(({ owner, quantity }, idx) => (\n            <ListItem key={idx} ml={6}>\n              {`${owner} (${quantity})`}\n            </ListItem>\n          ))}\n        </OrderedList>\n      )}\n      {ownerships.length === LIMIT && (\n        <RouterLink\n          to={{\n            pathname: `/owners?${new URLSearchParams({\n              nftId,\n              start_after: ownerships.slice(-1)[0].id,\n              offset: (Number(offset) + LIMIT).toString(),\n            })}`\n          }}\n        >\n          Next\n        </RouterLink>\n      )}\n    </Box>\n  )\n}\n\nexport default Owners"],"names":["DirectiveLocation","TokenKind","parser","useContext","invariant","React.useState","React.useLayoutEffect","React.useEffect","DocumentType","useRef","useState","InternalState","useCallback","result","useMemo","eagerMethods","key","RouterLink","chakra","ReactRouterLink","LIMIT","ownersQuery","polygon","gql","Owners","nftId","useParams","tokenId","deregexify","Array","isArray","params","useSearchParams","startAfter","get","offset","ownerships","setOwnerships","decId","BigInt","toString","query","contractNetwork","search","loading","error","message","queryError","data","useLazyQuery","useEffect","variables","contractAddress","toLowerCase","title","setTitle","ensProvider","roContract","useWeb3","setError","capitalize","lookup","uri","response","fetch","httpURL","json","name","process","nfts","length","Error","Promise","all","ownership","map","oship","owner","ens","lookupAddress","quantity","id","_Fragment","_jsx","Helmet","_jsxs","Number","idx","pathname","URLSearchParams","start_after","slice"],"mappings":"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"}